<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Last Known Position</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<style>
  body{ margin:0; min-height:100vh; display:flex; align-items:center; justify-content:center;
    background:#020617; background-image:url("https://deadboltmysterysociety.com/lkppagebackground/"); background-size:cover;
    background-position:center; background-repeat:no-repeat; color:#e5e7eb; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
    padding:20px; touch-action:none;
  }
  .wrapper{ max-width:1000px; width:100%; text-align:center; }
  h1{ font-size:1.8rem; margin-bottom:0.4rem; }
  .sub{ font-size:0.95rem; color:#d1d5db; margin-bottom:1rem; padding:0 10px; }

  /* LOCK */
  #lockSection{ margin-bottom:20px; }
  .lock-box{ display:inline-block; padding:18px 20px 22px; border-radius:12px;
    background:rgba(15,23,42,0.95); border:1px solid #374151; box-shadow:0 10px 30px rgba(0,0,0,0.7); }
  .rollers{ display:flex; gap:10px; justify-content:center; margin:10px 0 14px; }
  .roller{ background:#0b1120; border-radius:10px; padding:6px 8px; border:1px solid #4b5563;
    width:54px; display:flex; flex-direction:column; align-items:center; justify-content:center; }
  .roller button{ background:none; border:none; color:#e5e7eb; font-size:1rem; cursor:pointer; padding:0; line-height:1; user-select:none; }
  .digit{ font-size:1.4rem; margin:4px 0; font-weight:600; letter-spacing:1px; }
  #tryCodeBtn{ margin-top:4px; padding:6px 16px; border-radius:999px; border:none; background:#f97316; color:#111827; font-weight:600; cursor:pointer; font-size:0.95rem; }
  #lockMessage{ margin-top:8px; font-size:0.9rem; min-height:1.2em; }
  #lockMessage.error{ color:#fca5a5; } #lockMessage.success{ color:#bbf7d0; }
  .hidden{ display:none; }

  /* MAP */
  #compassSection{ opacity:0; pointer-events:none; transition:opacity 0.3s ease; }
  #compassSection.active{ opacity:1; pointer-events:auto; }

  .map-area{
    --map-max-width: 950px;
    position:relative;
    width:min(96vw, var(--map-max-width));
    aspect-ratio:3 / 2;
    margin:0 auto;
    border:2px solid #4b5563;
    border-radius:10px;
    background-image:url("https://deadboltmysterysociety.com/lkpmap/");
    background-size:cover;
    /* shift slightly down to avoid top crop */
    background-position:center 8%;
    background-repeat:no-repeat;
    overflow:hidden;
    touch-action:none;
    transform-origin:center center;
  }

  #compass{
    position:absolute; width:40px; height:40px; border-radius:50%;
    background:radial-gradient(circle at 30% 30%, #1f2937 0, #020617 60%, #000 100%);
    border:2px solid #e5e7eb; box-shadow:0 0 10px rgba(15,23,42,0.9);
    transform:translate(-50%,-50%); cursor:grab; z-index:5; touch-action:none;
  }
  #compass.dragging{ cursor:grabbing; }
  .compass-body{ position:relative; width:100%; height:100%; display:flex; align-items:center; justify-content:center; transition:transform 0.08s linear; }
  .needle{ position:relative; width:4px; height:60%; background:linear-gradient(to bottom, #ef4444 0 50%, #111827 50% 100%); border-radius:999px; box-shadow:0 0 4px rgba(239,68,68,0.7); }
  .needle::before{ content:""; position:absolute; top:-10px; left:50%; transform:translateX(-50%); border-left:5px solid transparent; border-right:5px solid transparent; border-bottom:10px solid #ef4444; }
  .needle::after{ content:""; position:absolute; bottom:-7px; left:50%; transform:translateX(-50%); border-left:4px solid transparent; border-right:4px solid transparent; border-top:7px solid #111827; }
  .compass-body.spin{ animation:spin 0.7s linear infinite; }
  @keyframes spin{ from{ transform:rotate(0deg);} to{ transform:rotate(360deg);} }
  #compass.pulse::before{ content:""; position:absolute; inset:-8px; border-radius:50%; border:2px solid rgba(252,211,77,0.9); box-shadow:0 0 12px rgba(252,211,77,0.9); animation:pulse 0.8s ease-out infinite; }

  .target-marker{ position:absolute; width:18px; height:18px; border:2px solid red; border-radius:50%; transform:translate(-50%,-50%); box-sizing:border-box; pointer-events:none; z-index:4; background:transparent; }
  .target-marker::after{ content:""; position:absolute; left:50%; top:50%; width:6px; height:6px; transform:translate(-50%,-50%); border-radius:50%; background: rgba(255,0,0,0.15); pointer-events:none; }

  /* small helper for debug: add .hide-markers to body to hide the red circles (keeps them in DOM) */
  .hide-markers .target-marker{ border-color: transparent; }
</style>
</head>
<body>
<div class="wrapper">

  <!-- LOCK -->
  <div id="lockSection">
    <h1>Bear Box</h1>
    <div class="sub">The old metal box is secured with a four-digit combination lock. Shaking the box carefully, you can hear some small metal piece moving around.</div>
    <div class="lock-box">
      <div class="rollers" id="rollers"></div>
      <button id="tryCodeBtn">Try the Code</button>
      <div id="lockMessage"></div>
    </div>
  </div>

  <!-- COMPASS -->
  <div id="compassSection" class="">
    <h1>Last Known Position</h1>
    <div class="sub">Drag the compass around the map. Its needle turns toward the nearest unseen ritual grounds.<br>When you’re directly over one, the compass goes wild.</div>

    <div id="mapArea" class="map-area">
      <div id="compass"><div id="compassBody" class="compass-body"><div class="needle"></div></div></div>
      <!-- marker elements appended by JS -->
    </div>
  </div>

</div>

<script>
/*************** LOCK LOGIC ***************/
const correctCode = "6436";
const rollersContainer = document.getElementById('rollers');
const lockMessage = document.getElementById('lockMessage');
const tryCodeBtn = document.getElementById('tryCodeBtn');
const lockSection = document.getElementById('lockSection');
const compassSection = document.getElementById('compassSection');

const digits = [0,0,0,0];

function renderRollers(){
  rollersContainer.innerHTML = "";
  for(let i=0;i<4;i++){
    const roller = document.createElement('div');
    roller.className = 'roller';
    roller.dataset.index = i;

    const up = document.createElement('button');
    up.textContent = '▲';
    up.className = 'roll-up';

    const digitDisplay = document.createElement('div');
    digitDisplay.className = 'digit';
    digitDisplay.textContent = digits[i];

    const down = document.createElement('button');
    down.textContent = '▼';
    down.className = 'roll-down';

    roller.appendChild(up);
    roller.appendChild(digitDisplay);
    roller.appendChild(down);
    rollersContainer.appendChild(roller);
  }
}
renderRollers();

rollersContainer.addEventListener('click', (e)=>{
  const roller = e.target.closest('.roller');
  if(!roller) return;
  const idx = parseInt(roller.dataset.index,10);
  if(e.target.classList.contains('roll-up')){
    digits[idx] = (digits[idx] + 1) % 10;
  } else if(e.target.classList.contains('roll-down')){
    digits[idx] = (digits[idx] + 9) % 10;
  } else {
    return;
  }
  roller.querySelector('.digit').textContent = digits[idx];
  lockMessage.textContent = "";
  lockMessage.className = "";
});

tryCodeBtn.addEventListener('click', ()=>{
  const entered = digits.join('');
  if(entered === correctCode){
    lockMessage.textContent = "The lock clicks open.";
    lockMessage.className = "success";
    lockSection.classList.add('hidden');
    compassSection.classList.add('active');
    setTimeout(()=>{
      centerCompass();
      positionTargetMarkers();
      setCompassSize();
      updateCompassBearing();
    }, 50);
  } else {
    lockMessage.textContent = "Hmmm... the lock doesn't budge.";
    lockMessage.className = "error";
  }
});

/*************** COMPASS / MAP LOGIC ***************/
const mapArea     = document.getElementById('mapArea');
const compass     = document.getElementById('compass');
const compassBody = document.getElementById('compassBody');

let scale = 1;
const SCALE_MIN = 0.6;
const SCALE_MAX = 3.0;
const SCALE_STEP = 0.06;

const GRID_COLS = 16;
const COMPASS_MIN = 24;
const COMPASS_MAX = 96;

/* percentage targets (x%, y%) */
const targets = [
  { x: 47.9, y: 71.7 },
  { x: 28.7, y: 56.2 },
  { x: 14.3, y: 13.6 },
  { x: 61.7, y: 42.3 },
  { x: 76.1, y: 13.8 },
  { x: 85.7, y: 49.7 }
];

const targetMarkers = [];

/* create DOM markers (one per target) and keep refs */
function createTargetMarkers(){
  targetMarkers.forEach(m => { if (m.el && m.el.parentNode) m.el.parentNode.removeChild(m.el); });
  targetMarkers.length = 0;
  targets.forEach((t, idx) => {
    const el = document.createElement('div');
    el.className = 'target-marker';
    el.dataset.index = idx;
    mapArea.appendChild(el);
    targetMarkers.push({ data: t, el });
  });
}
createTargetMarkers();

/* position markers using unscaled left/top so they align when scale applied */
function positionTargetMarkers(){
  const rect = mapArea.getBoundingClientRect();
  const w = rect.width / scale;
  const h = rect.height / scale;

  targetMarkers.forEach(m => {
    const tx = (m.data.x / 100) * w;
    const ty = (m.data.y / 100) * h;
    m.el.style.left = tx + 'px';
    m.el.style.top  = ty + 'px';
  });
}

function centerCompass() {
  const rect = mapArea.getBoundingClientRect();
  const w = rect.width / scale;
  const h = rect.height / scale;
  compass.style.left = (w / 2) + 'px';
  compass.style.top  = (h / 2) + 'px';
}

let isOnTarget = false;

/* HIT TEST: spin only when compass center is WITHIN the red marker circle (Option A)
   Uses actual element bounding rects (client pixels) so this exactly matches visuals.
*/
function updateCompassBearing() {
  const mapRect = mapArea.getBoundingClientRect();
  const compassRect = compass.getBoundingClientRect();

  // compass center in client pixels
  const cxClient = compassRect.left + compassRect.width / 2;
  const cyClient = compassRect.top  + compassRect.height / 2;

  // find nearest marker by element center (client px), but exact hit test will
  // check if compass center is INSIDE the marker circle using the marker radius.
  let nearest = null;
  let minDistSq = Infinity;

  for (const m of targetMarkers) {
    const r = m.el.getBoundingClientRect();
    const mx = r.left + r.width / 2;
    const my = r.top  + r.height / 2;
    const dx = mx - cxClient;
    const dy = my - cyClient;
    const d2 = dx*dx + dy*dy;
    if (d2 < minDistSq) {
      minDistSq = d2;
      nearest = { markerRect: r, mx, my, d2, data: m.data };
    }
  }

  if (!nearest) return;

  const distClient = Math.sqrt(nearest.d2);

  // marker radius in client pixels (we treat marker as circle)
  const markerRadiusClient = Math.min(nearest.markerRect.width, nearest.markerRect.height) / 2;

  // If compass center is strictly inside the marker circle -> spin
  if (distClient <= markerRadiusClient) {
    if (!isOnTarget) {
      isOnTarget = true;
      compassBody.classList.add('spin');
      compass.classList.add('pulse');
    }
    // while spinning, we don't change needle rotation
    return;
  } else {
    // if we were on target but moved outside marker -> stop spin
    if (isOnTarget) {
      isOnTarget = false;
      compassBody.classList.remove('spin');
      compass.classList.remove('pulse');
    }
    // rotate needle toward the target using unscaled coordinates for consistent visuals
    const mapUnscaledW = mapRect.width / scale;
    const mapUnscaledH = mapRect.height / scale;
    const cxUnscaled = (cxClient - mapRect.left) / scale;
    const cyUnscaled = (cyClient - mapRect.top)  / scale;
    // compute nearest target unscaled coordinates from percentage
    const txUnscaled = (nearest.data.x / 100) * mapUnscaledW;
    const tyUnscaled = (nearest.data.y / 100) * mapUnscaledH;
    const angleDeg = Math.atan2(tyUnscaled - cyUnscaled, txUnscaled - cxUnscaled) * 180 / Math.PI + 90;
    compassBody.style.transform = `rotate(${angleDeg}deg)`;
  }
}

/* responsive compass sizing (unscaled math) */
function setCompassSize() {
  const rect = mapArea.getBoundingClientRect();
  if (!rect.width || !rect.height) return;
  const mapUnscaledW = rect.width / scale;
  const cellWidth = mapUnscaledW / GRID_COLS;
  let diameter = Math.round(Math.max(COMPASS_MIN, Math.min(COMPASS_MAX, cellWidth * 0.85)));
  compass.style.width  = diameter + 'px';
  compass.style.height = diameter + 'px';
  const needle = compassBody.querySelector('.needle');
  if (needle) needle.style.height = Math.round(diameter * 0.60) + 'px';
  targetMarkers.forEach(m => {
    const markSize = Math.round(Math.max(10, Math.min(28, cellWidth * 0.45)));
    m.el.style.width = markSize + 'px';
    m.el.style.height = markSize + 'px';
  });
}

/* zoom handling (wheel + pinch) */
function applyScale(newScale) {
  scale = Math.max(SCALE_MIN, Math.min(SCALE_MAX, newScale));
  mapArea.style.transform = `scale(${scale})`;
  positionTargetMarkers();
  setCompassSize();
  updateCompassBearing();
}

mapArea.addEventListener('wheel', (e) => {
  if (!(e.ctrlKey || e.metaKey)) return;
  e.preventDefault();
  const delta = -e.deltaY;
  const factor = 1 + (delta > 0 ? SCALE_STEP : -SCALE_STEP);
  applyScale(scale * factor);
}, { passive: false });

/* pointer pinch */
const pointers = new Map();
let initialPinchDistance = null;
let initialPinchScale = null;
function getDistance(p1, p2){ const dx = p1.clientX - p2.clientX; const dy = p1.clientY - p2.clientY; return Math.hypot(dx, dy); }
mapArea.addEventListener('pointerdown', (e) => { pointers.set(e.pointerId, e); if (pointers.size === 2) { const [a,b] = Array.from(pointers.values()); initialPinchDistance = getDistance(a,b); initialPinchScale = scale; }});
mapArea.addEventListener('pointermove', (e) => { if (pointers.has(e.pointerId)) pointers.set(e.pointerId, e); if (pointers.size === 2 && initialPinchDistance && initialPinchScale != null) { const [a,b] = Array.from(pointers.values()); const dist = getDistance(a,b); const ratio = dist / initialPinchDistance; applyScale(initialPinchScale * ratio); }});
mapArea.addEventListener('pointerup', (e) => { pointers.delete(e.pointerId); if (pointers.size < 2) { initialPinchDistance = null; initialPinchScale = null; }});
mapArea.addEventListener('pointercancel', (e) => { pointers.delete(e.pointerId); if (pointers.size < 2) { initialPinchDistance = null; initialPinchScale = null; }});

/* dragging (unscaled coords) */
let dragging=false, startX=0, startY=0, compStartLeftUnscaled=0, compStartTopUnscaled=0;
compass.addEventListener('pointerdown', (e)=> {
  e.preventDefault(); dragging=true; compass.classList.add('dragging'); compass.setPointerCapture(e.pointerId);
  const mapRect = mapArea.getBoundingClientRect(), compRect = compass.getBoundingClientRect();
  startX = e.clientX; startY = e.clientY;
  compStartLeftUnscaled = (compRect.left + compRect.width/2 - mapRect.left) / scale;
  compStartTopUnscaled  = (compRect.top  + compRect.height/2 - mapRect.top) / scale;
  if (isOnTarget) { isOnTarget=false; compassBody.classList.remove('spin'); compass.classList.remove('pulse'); }
});
compass.addEventListener('pointermove', (e)=> {
  if (!dragging) return; e.preventDefault();
  const mapRect = mapArea.getBoundingClientRect(), compRect = compass.getBoundingClientRect();
  const deltaX = e.clientX - startX, deltaY = e.clientY - startY;
  const newLeftUnscaled = compStartLeftUnscaled + (deltaX / scale);
  const newTopUnscaled  = compStartTopUnscaled  + (deltaY / scale);
  const mapUnscaledW = mapRect.width / scale, mapUnscaledH = mapRect.height / scale;
  const compUnscaledW = compRect.width / scale, compUnscaledH = compRect.height / scale;
  const clampedLeft = Math.max(compUnscaledW/2, Math.min(newLeftUnscaled, mapUnscaledW - compUnscaledW/2));
  const clampedTop  = Math.max(compUnscaledH/2, Math.min(newTopUnscaled, mapUnscaledH - compUnscaledH/2));
  compass.style.left = clampedLeft + 'px'; compass.style.top = clampedTop + 'px';
  updateCompassBearing();
});
compass.addEventListener('pointerup', (e)=> { if(!dragging) return; e.preventDefault(); dragging=false; compass.classList.remove('dragging'); try{compass.releasePointerCapture(e.pointerId);}catch{} updateCompassBearing(); });
compass.addEventListener('pointercancel', (e)=> { if(!dragging) return; e.preventDefault(); dragging=false; compass.classList.remove('dragging'); });

/* keyboard */
const step = 8;
window.addEventListener('keydown', (e)=> {
  if (compassSection.className.indexOf('active') === -1) return;
  const key = e.key; const valid = ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','w','a','s','d','W','A','S','D'];
  if (!valid.includes(key)) return; e.preventDefault();
  if (isOnTarget) { isOnTarget=false; compassBody.classList.remove('spin'); compass.classList.remove('pulse'); }
  const mapRect = mapArea.getBoundingClientRect(); const mapUnscaledW = mapRect.width / scale; const mapUnscaledH = mapRect.height / scale;
  const compRect = compass.getBoundingClientRect(); const compUnscaledW = compRect.width / scale; const compUnscaledH = compRect.height / scale;
  let left = parseFloat(compass.style.left || '0'), top = parseFloat(compass.style.top || '0');
  if (key === 'ArrowUp'   || key === 'w' || key === 'W') top  -= step;
  if (key === 'ArrowDown' || key === 's' || key === 'S') top  += step;
  if (key === 'ArrowLeft' || key === 'a' || key === 'A') left -= step;
  if (key === 'ArrowRight'|| key === 'd' || key === 'D') left += step;
  left = Math.max(compUnscaledW/2, Math.min(left, mapUnscaledW - compUnscaledW/2));
  top  = Math.max(compUnscaledH/2, Math.min(top, mapUnscaledH - compUnscaledH/2));
  compass.style.left = left + 'px'; compass.style.top = top + 'px';
  updateCompassBearing();
});

/* resize observer + init */
const ro = new ResizeObserver(()=> { positionTargetMarkers(); setCompassSize(); if (compassSection.classList.contains('active')) updateCompassBearing(); });
ro.observe(mapArea);

window.addEventListener('load', ()=> {
  applyScale(scale);
  if (compassSection.classList.contains('active')) { centerCompass(); positionTargetMarkers(); setCompassSize(); updateCompassBearing(); }
  else { positionTargetMarkers(); setCompassSize(); }
});
window.addEventListener('resize', ()=> { setCompassSize(); positionTargetMarkers(); updateCompassBearing(); });

/* Optional helper: toggle marker visibility for testing */
/* usage: document.body.classList.add('hide-markers') */
</script>
</body>
</html>
