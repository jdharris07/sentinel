<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Last Known Position</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<style>
  body{
    margin:0;
    min-height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    background:#020617;
    background-image:url("https://deadboltmysterysociety.com/lkppagebackground/");
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
    color:#e5e7eb;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
    padding:20px;
    touch-action:none;
  }

  .wrapper{
    max-width:1000px;
    width:100%;
    text-align:center;
  }

  h1{
    font-size:1.8rem;
    margin-bottom:0.4rem;
  }

  .sub{
    font-size:0.95rem;
    color:#d1d5db;
    margin-bottom:1rem;
    padding:0 10px;
  }

  /* LOCK SECTION */

  #lockSection{
    margin-bottom:20px;
  }

  .lock-box{
    display:inline-block;
    padding:18px 20px 22px;
    border-radius:12px;
    background:rgba(15,23,42,0.95);
    border:1px solid #374151;
    box-shadow:0 10px 30px rgba(0,0,0,0.7);
  }

  .rollers{
    display:flex;
    gap:10px;
    justify-content:center;
    margin:10px 0 14px;
  }

  .roller{
    background:#0b1120;
    border-radius:10px;
    padding:6px 8px;
    border:1px solid #4b5563;
    width:54px;
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
  }

  .roller button{
    background:none;
    border:none;
    color:#e5e7eb;
    font-size:1rem;
    cursor:pointer;
    padding:0;
    line-height:1;
    user-select:none;
  }

  .roller button:active{
    transform:translateY(1px);
  }

  .digit{
    font-size:1.4rem;
    margin:4px 0;
    font-weight:600;
    letter-spacing:1px;
  }

  #tryCodeBtn{
    margin-top:4px;
    padding:6px 16px;
    border-radius:999px;
    border:none;
    background:#f97316;
    color:#111827;
    font-weight:600;
    cursor:pointer;
    font-size:0.95rem;
  }

  #tryCodeBtn:active{
    transform:translateY(1px);
  }

  #lockMessage{
    margin-top:8px;
    font-size:0.9rem;
    min-height:1.2em;
  }

  #lockMessage.error{
    color:#fca5a5;
  }
  #lockMessage.success{
    color:#bbf7d0;
  }

  /* fade */
  .hidden{
    display:none;
  }

  /* MAP + COMPASS SECTION */

  #compassSection{
    opacity:0;
    pointer-events:none;
    transition:opacity 0.3s ease;
  }
  #compassSection.active{
    opacity:1;
    pointer-events:auto;
  }

  .map-area{
    --map-max-width: 950px;
    position:relative;
    width:min(96vw, var(--map-max-width));
    aspect-ratio:3 / 2;
    margin:0 auto;
    border:2px solid #4b5563;
    border-radius:10px;
    background-image:url("https://deadboltmysterysociety.com/lkpmap/");
    background-size:cover;
    /* shifted slightly down so the top of the map image is less likely to be cropped */
    background-position:center 8%;
    background-repeat:no-repeat;
    overflow:hidden;
    touch-action:none;
  }

  /* default compass size will be overridden by JS to match grid cells */
  #compass{
    position:absolute;
    width:40px;
    height:40px;
    border-radius:50%;
    background:radial-gradient(circle at 30% 30%, #1f2937 0, #020617 60%, #000 100%);
    border:2px solid #e5e7eb;
    box-shadow:0 0 10px rgba(15,23,42,0.9);
    transform:translate(-50%, -50%);
    cursor:grab;
    z-index:5;
    touch-action:none;
  }

  #compass.dragging{
    cursor:grabbing;
  }

  .compass-body{
    position:relative;
    width:100%;
    height:100%;
    display:flex;
    align-items:center;
    justify-content:center;
    transition:transform 0.08s linear;
  }

  .needle{
    position:relative;
    width:4px;
    height:60%;
    background:linear-gradient(to bottom, #ef4444 0 50%, #111827 50% 100%);
    border-radius:999px;
    box-shadow:0 0 4px rgba(239,68,68,0.7);
  }

  .needle::before{
    content:"";
    position:absolute;
    top:-10px;
    left:50%;
    transform:translateX(-50%);
    border-left:5px solid transparent;
    border-right:5px solid transparent;
    border-bottom:10px solid #ef4444;
  }

  .needle::after{
    content:"";
    position:absolute;
    bottom:-7px;
    left:50%;
    transform:translateX(-50%);
    border-left:4px solid transparent;
    border-right:4px solid transparent;
    border-top:7px solid #111827;
  }

  .compass-body.spin{
    animation:spin 0.7s linear infinite;
  }

  @keyframes spin{
    from{ transform:rotate(0deg); }
    to{ transform:rotate(360deg); }
  }

  #compass.pulse::before{
    content:"";
    position:absolute;
    inset:-8px;
    border-radius:50%;
    border:2px solid rgba(252,211,77,0.9);
    box-shadow:0 0 12px rgba(252,211,77,0.9);
    animation:pulse 0.8s ease-out infinite;
  }

  @keyframes pulse{
    from{ transform:scale(0.9); opacity:1; }
    to{ transform:scale(1.15); opacity:0; }
  }

  /* TARGET MARKERS (red outlined circles) */
  .target-marker{
    position:absolute;
    width:18px;
    height:18px;
    border:0px solid red;
    border-radius:50%;
    transform:translate(-50%,-50%);
    box-sizing:border-box;
    pointer-events:none; /* don't block touches/clicks */
    z-index:4; /* below compass (which is z-index:5) */
    background: transparent;
  }

  .target-marker::after{
    content:"";
    position:absolute;
    left:50%;
    top:50%;
    width:6px;
    height:6px;
    transform:translate(-50%,-50%);
    border-radius:50%;
    background: rgba(255,0,0,0.15);
    pointer-events:none;
  }

</style>
</head>
<body>
<div class="wrapper">

  <!-- LOCK SECTION -->
  <div id="lockSection">
    <h1>Bear Box</h1>
    <div class="sub">
      The old metal box is secured with a four-digit combination lock.  
      Shaking the box carefully, you can hear some small metal piece moving around.
    </div>

    <div class="lock-box">
      <div class="rollers" id="rollers">
        <!-- rollers are created by JS -->
      </div>
      <button id="tryCodeBtn">Try the Code</button>
      <div id="lockMessage"></div>
    </div>
  </div>

  <!-- COMPASS SECTION -->
  <div id="compassSection" class="">
    <h1>Last Known Position</h1>
    <div class="sub">
      Drag the compass around the map. Its needle turns toward the nearest unseen ritual grounds.<br>
      When you’re directly over one, the compass goes wild.
    </div>

    <div id="mapArea" class="map-area">
      <div id="compass">
        <div id="compassBody" class="compass-body">
          <div class="needle"></div>
        </div>
      </div>
      <!-- target marker elements will be appended here by JS -->
    </div>
  </div>

</div>

<script>
  /*************** LOCK LOGIC ***************/
  const correctCode = "6436";
  const rollersContainer = document.getElementById('rollers');
  const lockMessage = document.getElementById('lockMessage');
  const tryCodeBtn = document.getElementById('tryCodeBtn');
  const lockSection = document.getElementById('lockSection');
  const compassSection = document.getElementById('compassSection');

  const digits = [0,0,0,0];

  function renderRollers(){
    rollersContainer.innerHTML = "";
    for(let i=0;i<4;i++){
      const roller = document.createElement('div');
      roller.className = 'roller';
      roller.dataset.index = i;

      const up = document.createElement('button');
      up.textContent = '▲';
      up.className = 'roll-up';

      const digitDisplay = document.createElement('div');
      digitDisplay.className = 'digit';
      digitDisplay.textContent = digits[i];

      const down = document.createElement('button');
      down.textContent = '▼';
      down.className = 'roll-down';

      roller.appendChild(up);
      roller.appendChild(digitDisplay);
      roller.appendChild(down);
      rollersContainer.appendChild(roller);
    }
  }

  renderRollers();

  rollersContainer.addEventListener('click', (e)=>{
    const roller = e.target.closest('.roller');
    if(!roller) return;
    const idx = parseInt(roller.dataset.index,10);
    if(e.target.classList.contains('roll-up')){
      digits[idx] = (digits[idx] + 1) % 10;
    } else if(e.target.classList.contains('roll-down')){
      digits[idx] = (digits[idx] + 9) % 10; // -1 mod 10
    } else {
      return;
    }
    roller.querySelector('.digit').textContent = digits[idx];
    lockMessage.textContent = "";
    lockMessage.className = "";
  });

  tryCodeBtn.addEventListener('click', ()=>{
    const entered = digits.join('');
    if(entered === correctCode){
      lockMessage.textContent = "The lock clicks open.";
      lockMessage.className = "success";
      // reveal compass section
      lockSection.classList.add('hidden');
      compassSection.classList.add('active');
      // ensure map/compass layout is ready
      setTimeout(()=>{
        centerCompass();
        positionTargetMarkers();
        setCompassSize();
        updateCompassBearing();
      }, 50);
    } else {
      lockMessage.textContent = "Hmmm... the lock doesn't budge.";
      lockMessage.className = "error";
    }
  });

  /*************** COMPASS / MAP LOGIC ***************/
  const mapArea     = document.getElementById('mapArea');
  const compass     = document.getElementById('compass');
  const compassBody = document.getElementById('compassBody');

  // responsive sizing config
  const GRID_COLS = 16;   // set to number of vertical grid columns in your map image
  const COMPASS_MIN = 24; // px - smallest diameter
  const COMPASS_MAX = 96; // px - largest diameter

  // percentage-based targets (x% , y%)
  const targets = [
    { x: 47.9, y: 71.7 },
    { x: 28.7, y: 56.2 },
    { x: 14.3, y: 13.6 },
    { x: 61.7, y: 42.3 },
    { x: 76.1, y: 13.8 },
    { x: 85.7, y: 49.7 }
  ];

  // create marker elements (one per target) and keep refs so we can reposition
  const targetMarkers = [];

  function createTargetMarkers(){
    // clear any existing markers
    targetMarkers.forEach(m => {
      if (m.el && m.el.parentNode) m.el.parentNode.removeChild(m.el);
    });
    targetMarkers.length = 0;

    targets.forEach((t, idx) => {
      const el = document.createElement('div');
      el.className = 'target-marker';
      el.dataset.index = idx;
      // append to mapArea so positions are relative to it
      mapArea.appendChild(el);
      targetMarkers.push({ data: t, el });
    });
  }

  // position the markers based on current map size
  function positionTargetMarkers(){
    const rect = mapArea.getBoundingClientRect();
    const w = rect.width;
    const h = rect.height;

    targetMarkers.forEach(m => {
      const tx = (m.data.x / 100) * w;
      const ty = (m.data.y / 100) * h;
      // position using left/top (mapArea is position:relative)
      m.el.style.left = tx + 'px';
      m.el.style.top  = ty + 'px';
    });
  }

  function centerCompass() {
    const rect = mapArea.getBoundingClientRect();
    compass.style.left = rect.width / 2 + 'px';
    compass.style.top  = rect.height / 2 + 'px';
  }

  let isOnTarget = false;

  // ---------- NO-SNAP updateCompassBearing ----------
  function updateCompassBearing() {
    const mapRect     = mapArea.getBoundingClientRect();
    const compassRect = compass.getBoundingClientRect();

    let cx = (compassRect.left + compassRect.width / 2) - mapRect.left;
    let cy = (compassRect.top  + compassRect.height / 2) - mapRect.top;

    const w = mapRect.width;
    const h = mapRect.height;

    let nearest = null;
    let minDistSq = Infinity;

    // compute px positions for targets
    targets.forEach(t => {
      const tx = (t.x / 100) * w;
      const ty = (t.y / 100) * h;
      const dx = tx - cx;
      const dy = ty - cy;
      const distSq = dx*dx + dy*dy;
      if (distSq < minDistSq) {
        minDistSq = distSq;
        nearest = { tx, ty, distSq };
      }
    });

    if (!nearest) return;

    const dx = nearest.tx - cx;
    const dy = nearest.ty - cy;
    const dist = Math.sqrt(nearest.distSq);

    const hitRadius = 40;   // if you move outside this after being 'on target', it will unpin
    const snapRadius = 35;  // within this radius we trigger the 'on-target' behavior but do NOT move the compass

    if (dist <= snapRadius) {
      // NO SNAPPING: keep compass where it is, but enter on-target visual state
      if (!isOnTarget) {
        isOnTarget = true;
        compassBody.classList.add('spin');
        compass.classList.add('pulse');
      }
      // while spinning we don't need to change the needle rotation
      return;
    } else {
      // If previously pinned and moved past hitRadius, stop spin
      if (isOnTarget && dist > hitRadius) {
        isOnTarget = false;
        compassBody.classList.remove('spin');
        compass.classList.remove('pulse');
      }
      // rotate needle toward target (normal behavior)
      const angleDeg = Math.atan2(dy, dx) * 180 / Math.PI + 90;
      compassBody.style.transform = `rotate(${angleDeg}deg)`;
    }
  }
  // ---------- end updateCompassBearing ----------

  // initialize markers (but don't position until map size known)
  createTargetMarkers();

  // ---------- Responsive compass sizing ----------
  function setCompassSize() {
    const rect = mapArea.getBoundingClientRect();
    if (!rect.width || !rect.height) return;

    const cellWidth = rect.width / GRID_COLS;
    // use 0.85 of cell width so the compass comfortably fits inside one grid cell
    let diameter = Math.round(Math.max(COMPASS_MIN, Math.min(COMPASS_MAX, cellWidth * 0.85)));

    compass.style.width  = diameter + 'px';
    compass.style.height = diameter + 'px';

    // adjust needle length proportionally
    const needle = compassBody.querySelector('.needle');
    if (needle) {
      needle.style.height = Math.round(diameter * 0.60) + 'px';
    }

    // scale target markers so they remain visually consistent
    targetMarkers.forEach(m => {
      const markSize = Math.round(Math.max(10, Math.min(28, cellWidth * 0.45)));
      m.el.style.width = markSize + 'px';
      m.el.style.height = markSize + 'px';
    });
  }

  // Use ResizeObserver to reposition markers responsively when map resizes
  const ro = new ResizeObserver(() => {
    positionTargetMarkers();
    setCompassSize();
    // if compass is visible, update bearing so transform calculations are correct
    if (compassSection.classList.contains('active')) updateCompassBearing();
  });
  ro.observe(mapArea);

  // call sizing immediately in case map is already sized
  setCompassSize();

  // dragging
  let dragging = false;
  let startX   = 0;
  let startY   = 0;
  let compStartLeft = 0;
  let compStartTop  = 0;

  compass.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    dragging = true;
    compass.classList.add('dragging');
    compass.setPointerCapture(e.pointerId);

    const mapRect  = mapArea.getBoundingClientRect();
    const compRect = compass.getBoundingClientRect();

    startX = e.clientX;
    startY = e.clientY;

    compStartLeft = compRect.left - mapRect.left + compRect.width / 2;
    compStartTop  = compRect.top  - mapRect.top  + compRect.height / 2;

    // If pinned, stop spin immediately so movement takes precedence.
    if (isOnTarget) {
      isOnTarget = false;
      compassBody.classList.remove('spin');
      compass.classList.remove('pulse');
    }
  });

  compass.addEventListener('pointermove', (e) => {
    if (!dragging) return;
    e.preventDefault();

    const mapRect = mapArea.getBoundingClientRect();
    const cW = compass.offsetWidth;
    const cH = compass.offsetHeight;

    const deltaX = e.clientX - startX;
    const deltaY = e.clientY - startY;

    let newLeft = compStartLeft + deltaX;
    let newTop  = compStartTop  + deltaY;

    newLeft = Math.max(cW/2, Math.min(newLeft, mapRect.width  - cW/2));
    newTop  = Math.max(cH/2, Math.min(newTop,  mapRect.height - cH/2));

    compass.style.left = newLeft + 'px';
    compass.style.top  = newTop  + 'px';

    updateCompassBearing();
  });

  compass.addEventListener('pointerup', (e) => {
    if (!dragging) return;
    e.preventDefault();
    dragging = false;
    compass.classList.remove('dragging');
    try { compass.releasePointerCapture(e.pointerId); } catch (err) {}
    updateCompassBearing(); // finalize orientation after drag
  });

  compass.addEventListener('pointercancel', (e) => {
    if (!dragging) return;
    e.preventDefault();
    dragging = false;
    compass.classList.remove('dragging');
  });

  // keyboard (desktop)
  const step = 8;

  window.addEventListener('keydown', (e) => {
    if (compassSection.className.indexOf('active') === -1) return; // only when visible

    const key = e.key;
    const valid = ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','w','a','s','d','W','A','S','D'];
    if (!valid.includes(key)) return;

    e.preventDefault();

    // If pinned to a ritual, stop the spin immediately when user moves with keyboard.
    if (isOnTarget) {
      isOnTarget = false;
      compassBody.classList.remove('spin');
      compass.classList.remove('pulse');
    }

    const mapRect = mapArea.getBoundingClientRect();
    const cW = compass.offsetWidth;
    const cH = compass.offsetHeight;

    let left = parseFloat(compass.style.left || '0');
    let top  = parseFloat(compass.style.top  || '0');

    if (key === 'ArrowUp'   || key === 'w' || key === 'W') top  -= step;
    if (key === 'ArrowDown' || key === 's' || key === 'S') top  += step;
    if (key === 'ArrowLeft' || key === 'a' || key === 'A') left -= step;
    if (key === 'ArrowRight'|| key === 'd' || key === 'D') left += step;

    left = Math.max(cW/2, Math.min(left, mapRect.width  - cW/2));
    top  = Math.max(cH/2, Math.min(top,  mapRect.height - cH/2));

    compass.style.left = left + 'px';
    compass.style.top  = top  + 'px';

    updateCompassBearing();
  });

  window.addEventListener('resize', () => {
    setCompassSize();
    if (compassSection.className.indexOf('active') !== -1){
      centerCompass();
      positionTargetMarkers();
      updateCompassBearing();
    }
  });

  // initial layout when page loads: center compass and position markers if visible
  window.addEventListener('load', () => {
    setCompassSize();
    if (compassSection.classList.contains('active')) {
      centerCompass();
      positionTargetMarkers();
      updateCompassBearing();
    } else {
      // position markers anyway so when revealed they are correct
      positionTargetMarkers();
    }
  });

</script>
</body>
</html>
