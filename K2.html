<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport"
  content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
<title>K2 EMF — Mobile (Calibrate + Fine-Tune)</title>
<style>
  :root{
    --bg:#0a0f18; --ink:#e7f0ff; --muted:#aebedb; --grid:#23314a;
    --tile:#0e1524; --tile2:#121b2c; --rad:14px;

    /* Size of each LED lens (as % of image width). Tweak if your PNG wells are small/large. */
    --led-size: 8.8%;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background:linear-gradient(180deg,#060912,#0e1423);
    color:var(--ink); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
    -webkit-font-smoothing:antialiased;
  }

  header{
    position:sticky; top:0; z-index:10;
    padding: max(10px, env(safe-area-inset-top)) 16px 8px;
    background:rgba(10,15,25,.9);
    border-bottom:1px solid #1c2740;
    display:flex; align-items:center; justify-content:space-between; gap:8px; flex-wrap:wrap;
  }
  h1{margin:0; font-size:16px; letter-spacing:.3px}
  .btn{
    appearance:none; border:1px solid #2a3a5a; background:#132139; color:var(--ink);
    padding:8px 12px; border-radius:10px; font-weight:700; font-size:13px;
  }

  .wrap{
    padding:10px max(10px, env(safe-area-inset-left)) max(10px, env(safe-area-inset-bottom)) max(10px, env(safe-area-inset-right));
  }

  /* Field uses portrait aspect; fully responsive */
  .field{
    position:relative; width:100%; max-width:600px; margin:0 auto;
    aspect-ratio: 9 / 16;
    background:linear-gradient(180deg,var(--tile),var(--tile2));
    border:1px solid var(--grid); border-radius:12px;
    box-shadow: inset 0 10px 28px rgba(0,0,0,.45);
    overflow:hidden; touch-action:none;
  }
  .field.dev::before{
    content:""; position:absolute; inset:0; pointer-events:none; opacity:.25;
    background:
      linear-gradient(#1b2943 1px, transparent 1px),
      linear-gradient(90deg,#1b2943 1px, transparent 1px);
    background-size: 8% 8%;
  }

  /* Hotspots (percent-based, hidden in play; shown in DEV) */
  .hotspot{
    position:absolute; border:1px dashed transparent; border-radius:10px;
    background:transparent; color:transparent; display:grid; place-items:center;
    font-size:12px; padding:4px;
  }
  .field.dev .hotspot{ border-color:#2b3c5f; background:rgba(255,255,255,.03); color:var(--muted); }
  .hotspot.active{ outline:2px solid #7ee2b8; box-shadow:0 0 0 2px rgba(126,226,184,.25) }

  /* Draggable meter — IMPORTANT: only top + left (no bottom/right) */
  .meter{
    position:absolute; width: clamp(120px, 32vw, 220px);
    left: 3%; top: 65%;
    user-select:none; -webkit-user-drag:none; cursor:grab; touch-action:none; display:inline-block;
  }
  .meter.dragging{ cursor:grabbing }
  .meter img{display:block; width:100%; height:auto; pointer-events:none}

  /* LED overlay fills the IMAGE bounds */
  .leds{ position:absolute; inset:0; pointer-events:none; }
  .led{
    position:absolute; width:var(--led-size); aspect-ratio:1/1; border-radius:50%;
    opacity:.18; transform: translate(-50%, -50%);
    background: radial-gradient(circle at 50% 55%,
              rgba(255,255,255,.35) 0 28%,
              rgba(255,255,255,.05) 29% 55%,
              rgba(0,0,0,.15) 56% 100%);
  }
  /* CSS variables hold the calibrated positions (defaults are rough; CAL/TUNE overwrite). */
  .l1{ left: var(--l1x, 19.5%); top: var(--l1y, 14%);  --col:#33d16a; } /* left green  */
  .l2{ left: var(--l2x, 36.5%); top: var(--l2y, 11%);  --col:#27c15b; } /* right green */
  .l3{ left: var(--l3x, 53.5%); top: var(--l3y, 10%);  --col:#f1d44e; } /* yellow      */
  .l4{ left: var(--l4x, 70.5%); top: var(--l4y, 11%);  --col:#ff8a3d; } /* orange      */
  .l5{ left: var(--l5x, 86.5%); top: var(--l5y, 14%);  --col:#ff4b4b; } /* red         */
  .led.on{
    opacity:1;
    box-shadow:0 0 6px var(--col), 0 0 18px color-mix(in srgb, var(--col) 55%, transparent);
    background: radial-gradient(circle at 50% 55%,
              #fff 0 18%,
              color-mix(in srgb, var(--col) 70%, #fff) 19% 52%,
              color-mix(in srgb, var(--col) 85%, #000) 53% 100%);
  }

  .status{ text-align:center; font-size:14px; color:var(--muted); margin-top:8px; min-height:22px }

  /* Calibration/Fine-tune crosshairs */
  .crosshair{
    position:absolute; width:16px; height:16px; border-radius:50%;
    border:2px solid #7ee2b8; box-shadow:0 0 10px rgba(126,226,184,.5);
    transform:translate(-50%,-50%); display:none; background:rgba(126,226,184,.12);
    cursor:grab; touch-action:none;
  }
  .cal .crosshair, .tune .crosshair{ display:block; }
  .crosshair.dragging{ cursor:grabbing }
</style>
</head>
<body>
<header>
  <h1>K2 EMF Hotspots</h1>
  <div>
    <button id="devBtn" class="btn" aria-pressed="false">DEV</button>
    <button id="calBtn" class="btn" aria-pressed="false">CAL</button>
    <button id="tuneBtn" class="btn" aria-pressed="false">TUNE</button>
    <button id="resetCalBtn" class="btn">Reset CAL</button>
  </div>
</header>

<div class="wrap">
  <div id="field" class="field" aria-label="Playfield">
    <!-- Hotspots: data-x/y/w/h in %, data-level = 0–5 LEDs -->
    <div class="hotspot" data-x="5"  data-y="6"  data-w="22" data-h="14" data-level="2">2 lights</div>
    <div class="hotspot" data-x="31" data-y="18" data-w="22" data-h="14" data-level="3">3 lights</div>
    <div class="hotspot" data-x="57" data-y="7"  data-w="22" data-h="14" data-level="4">4 lights</div>
    <div class="hotspot" data-x="72" data-y="28" data-w="22" data-h="14" data-level="5">5 lights</div>
    <div class="hotspot" data-x="38" data-y="64" data-w="24" data-h="16" data-level="0">Quiet</div>

    <!-- K2 Meter -->
    <div id="meter" class="meter" aria-label="K2 Meter" role="img">
      <img id="k2img" src="K2meter.png" alt="K2 EMF meter" />
      <div class="leds">
        <span class="led l1"></span>
        <span class="led l2"></span>
        <span class="led l3"></span>
        <span class="led l4"></span>
        <span class="led l5"></span>
      </div>
      <!-- crosshairs for cal/tune -->
      <span id="ch1" class="crosshair"></span>
      <span id="ch2" class="crosshair"></span>
      <span id="ch3" class="crosshair"></span>
      <span id="ch4" class="crosshair"></span>
      <span id="ch5" class="crosshair"></span>
    </div>
  </div>

  <div id="status" class="status" aria-live="polite"></div>
</div>

<script>
const field = document.getElementById('field');
const meter = document.getElementById('meter');
const img   = document.getElementById('k2img');
const statusEl = document.getElementById('status');

const devBtn = document.getElementById('devBtn');
const calBtn = document.getElementById('calBtn');
const tuneBtn = document.getElementById('tuneBtn');
const resetCalBtn = document.getElementById('resetCalBtn');

const leds = [...meter.querySelectorAll('.led')];
const hotspots = [...field.querySelectorAll('.hotspot')];
const crosshairs = [1,2,3,4,5].map(n=>document.getElementById('ch'+n));

let dragging = false;
let start = {x:0, y:0};
let offset = {x: meter.offsetLeft, y: meter.offsetTop};
let lastLevel = -1;

/* ---------- Hotspots layout (percentage) ---------- */
function layoutHotspots(){
  hotspots.forEach(h=>{
    const x = parseFloat(h.dataset.x), y = parseFloat(h.dataset.y);
    const w = parseFloat(h.dataset.w), hgt = parseFloat(h.dataset.h);
    h.style.left = x + '%';
    h.style.top = y + '%';
    h.style.width = w + '%';
    h.style.height = hgt + '%';
  });
}
window.addEventListener('resize', layoutHotspots);
layoutHotspots();

/* ---------- Rect + overlap helpers ---------- */
function rect(el){ return el.getBoundingClientRect(); }
function overlapRatio(a, b){
  const x1 = Math.max(a.left, b.left), y1 = Math.max(a.top, b.top);
  const x2 = Math.min(a.right, b.right), y2 = Math.min(a.bottom, b.bottom);
  const w = Math.max(0, x2 - x1), h = Math.max(0, y2 - y1);
  const inter = w*h, area = b.width * b.height;
  return area ? inter / area : 0;
}

/* ---------- Lights + (optional) haptics ---------- */
function setLights(n){
  leds.forEach((el, i)=> el.classList.toggle('on', i < n));
  if(n !== lastLevel){
    if('vibrate' in navigator){ navigator.vibrate(n ? [15] : 0); }
    statusEl.textContent = n===1 ? `Level: ${n} light` : `Level: ${n} lights`;
    lastLevel = n;
  }
}

/* ---------- Hotspot check ---------- */
function highlightHotspot(active){ hotspots.forEach(h => h.classList.toggle('active', h === active)); }
function checkHotspots(){
  const m = rect(meter);
  let best = null, bestRatio = 0;
  for(const h of hotspots){
    const r = rect(h);
    const ratio = overlapRatio(m, r);
    if(ratio > bestRatio){ bestRatio = ratio; best = h; }
  }
  const THRESH = 0.25;
  if(best && bestRatio >= THRESH){
    highlightHotspot(best);
    const level = parseInt(best.dataset.level || '0', 10);
    setLights(level);
  }else{
    highlightHotspot(null);
    setLights(0);
  }
}

/* ---------- Dragging (top/left only) ---------- */
function clamp(v, a, b){ return Math.min(b, Math.max(a, v)); }
function moveTo(x, y){
  const maxX = field.clientWidth - meter.clientWidth;
  const maxY = field.clientHeight - meter.clientHeight;
  offset.x = clamp(x, 0, maxX);
  offset.y = clamp(y, 0, maxY);
  meter.style.left = offset.x + 'px';
  meter.style.top  = offset.y + 'px';
  meter.style.bottom = 'auto'; // never use bottom/right (prevents stretch)
  checkHotspots();
}

meter.addEventListener('pointerdown', (e)=>{
  if(calActive || tuneActive) return;
  dragging = true;
  meter.setPointerCapture(e.pointerId);
  meter.classList.add('dragging');
  start.x = e.clientX - offset.x;
  start.y = e.clientY - offset.y;
  e.preventDefault();
});
meter.addEventListener('pointermove', (e)=>{
  if(!dragging) return;
  moveTo(e.clientX - start.x, e.clientY - start.y);
});
meter.addEventListener('pointerup', (e)=>{
  dragging = false;
  meter.classList.remove('dragging');
  meter.releasePointerCapture?.(e.pointerId);
});
meter.addEventListener('pointercancel', ()=>{
  dragging = false;
  meter.classList.remove('dragging');
});

/* ---------- DEV toggle ---------- */
devBtn.addEventListener('click', ()=>{
  const on = !field.classList.contains('dev');
  field.classList.toggle('dev', on);
  devBtn.setAttribute('aria-pressed', on ? 'true' : 'false');
});

/* ---------- Calibration (click 5 lens centers) ---------- */
const VARS = ["--l1x","--l1y","--l2x","--l2y","--l3x","--l3y","--l4x","--l4y","--l5x","--l5y"];
let calActive = false, calStep = 0;

function applyCalibration(vars){
  meter.style.setProperty('--l1x', vars.l1x); meter.style.setProperty('--l1y', vars.l1y);
  meter.style.setProperty('--l2x', vars.l2x); meter.style.setProperty('--l2y', vars.l2y);
  meter.style.setProperty('--l3x', vars.l3x); meter.style.setProperty('--l3y', vars.l3y);
  meter.style.setProperty('--l4x', vars.l4x); meter.style.setProperty('--l4y', vars.l4y);
  meter.style.setProperty('--l5x', vars.l5x); meter.style.setProperty('--l5y', vars.l5y);
  // show crosshairs where they are (used by TUNE too)
  const arr = [[vars.l1x,vars.l1y],[vars.l2x,vars.l2y],[vars.l3x,vars.l3y],[vars.l4x,vars.l4y],[vars.l5x,vars.l5y]];
  arr.forEach(([x,y],i)=>{ crosshairs[i].style.left=x; crosshairs[i].style.top=y; });
}
function loadCalibration(){
  const raw = localStorage.getItem('k2_cal');
  if(!raw) return;
  try{ applyCalibration(JSON.parse(raw)); }catch(e){}
}
loadCalibration();

function startCal(){
  calActive = true; calStep = 0;
  calBtn.setAttribute('aria-pressed','true');
  meter.classList.add('cal');
  setLights(5); // show all while aligning
  statusEl.textContent = 'CAL: Click LEFT GREEN lens (1 of 5)';
}
function endCal(){
  calActive = false;
  calBtn.setAttribute('aria-pressed','false');
  meter.classList.remove('cal');
  statusEl.textContent = '';
  setLights(0);
}
calBtn.addEventListener('click', ()=>{ if(calActive) endCal(); else startCal(); });

resetCalBtn.addEventListener('click', ()=>{
  localStorage.removeItem('k2_cal');
  VARS.forEach(v => meter.style.removeProperty(v));
  statusEl.textContent = 'Calibration cleared.';
  setLights(0);
});

/* click to set 5 points */
meter.addEventListener('click', (e)=>{
  if(!calActive) return;
  const ir = img.getBoundingClientRect();
  const toPct = (n)=> `${n.toFixed(2)}%`;
  const xPct = ((e.clientX - ir.left) / ir.width * 100);
  const yPct = ((e.clientY - ir.top)  / ir.height * 100);

  const order = [
    ['--l1x','--l1y','RIGHT GREEN'],
    ['--l2x','--l2y','YELLOW'],
    ['--l3x','--l3y','ORANGE'],
    ['--l4x','--l4y','RED'],
    ['--l5x','--l5y','(done)'],
  ];
  const map = [
    ['--l1x','--l1y','left GREEN'],
    ['--l2x','--l2y','right GREEN'],
    ['--l3x','--l3y','YELLOW'],
    ['--l4x','--l4y','ORANGE'],
    ['--l5x','--l5y','RED'],
  ];
  const [vx, vy] = map[calStep];
  meter.style.setProperty(vx, toPct(xPct));
  meter.style.setProperty(vy, toPct(yPct));
  crosshairs[calStep].style.left = toPct(xPct);
  crosshairs[calStep].style.top  = toPct(yPct);

  calStep++;
  if(calStep < 5){
    statusEl.textContent = `CAL: Click ${map[calStep][2]} lens (${calStep+1} of 5)`;
  }else{
    const vars = {
      l1x:getComputedStyle(meter).getPropertyValue('--l1x').trim(),
      l1y:getComputedStyle(meter).getPropertyValue('--l1y').trim(),
      l2x:getComputedStyle(meter).getPropertyValue('--l2x').trim(),
      l2y:getComputedStyle(meter).getPropertyValue('--l2y').trim(),
      l3x:getComputedStyle(meter).getPropertyValue('--l3x').trim(),
      l3y:getComputedStyle(meter).getPropertyValue('--l3y').trim(),
      l4x:getComputedStyle(meter).getPropertyValue('--l4x').trim(),
      l4y:getComputedStyle(meter).getPropertyValue('--l4y').trim(),
      l5x:getComputedStyle(meter).getPropertyValue('--l5x').trim(),
      l5y:getComputedStyle(meter).getPropertyValue('--l5y').trim(),
    };
    localStorage.setItem('k2_cal', JSON.stringify(vars));
    statusEl.textContent = 'Calibration saved.';
    endCal();
  }
});

/* ---------- Fine-Tune: drag crosshairs to nudge per-LED ---------- */
let tuneActive = false, dragIdx = -1;

function syncCrosshairsFromVars(){
  // ensure crosshairs reflect current computed positions (handles first open)
  for(let i=0;i<5;i++){
    const xs = getComputedStyle(meter).getPropertyValue(`--l${i+1}x`).trim();
    const ys = getComputedStyle(meter).getPropertyValue(`--l${i+1}y`).trim();
    if(xs && ys){ crosshairs[i].style.left = xs; crosshairs[i].style.top = ys; }
  }
}
function startTune(){
  tuneActive = true; tuneBtn.setAttribute('aria-pressed','true');
  meter.classList.add('tune'); syncCrosshairsFromVars(); setLights(5);
  statusEl.textContent = 'TUNE: Drag crosshairs onto lens centers (saves automatically).';
}
function endTune(){
  tuneActive = false; tuneBtn.setAttribute('aria-pressed','false');
  meter.classList.remove('tune'); statusEl.textContent = ''; setLights(0);
}
tuneBtn.addEventListener('click', ()=>{ if(tuneActive) endTune(); else startTune(); });

crosshairs.forEach((ch, i)=>{
  ch.addEventListener('pointerdown', (e)=>{
    if(!tuneActive) return;
    dragIdx = i; ch.setPointerCapture(e.pointerId); ch.classList.add('dragging'); e.preventDefault();
  });
  ch.addEventListener('pointermove', (e)=>{
    if(!tuneActive || dragIdx !== i) return;
    const ir = img.getBoundingClientRect();
    const xPct = ((e.clientX - ir.left) / ir.width * 100);
    const yPct = ((e.clientY - ir.top)  / ir.height * 100);
    const clampPct = (n)=> `${Math.max(0, Math.min(100, n)).toFixed(2)}%`;
    const vx = `--l${i+1}x`, vy = `--l${i+1}y`;
    const xs = clampPct(xPct), ys = clampPct(yPct);
    meter.style.setProperty(vx, xs);
    meter.style.setProperty(vy, ys);
    ch.style.left = xs; ch.style.top = ys;
    // save live
    const raw = localStorage.getItem('k2_cal'); const vars = raw ? JSON.parse(raw) : {};
    vars[`l${i+1}x`] = xs; vars[`l${i+1}y`] = ys;
    localStorage.setItem('k2_cal', JSON.stringify(vars));
  });
  ch.addEventListener('pointerup', (e)=>{ ch.classList.remove('dragging'); dragIdx = -1; });
  ch.addEventListener('pointercancel', ()=>{ ch.classList.remove('dragging'); dragIdx = -1; });
});

/* ---------- Init ---------- */
setLights(0);
checkHotspots();
</script>
</body>
</html>
